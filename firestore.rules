/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model where all data
 * is private and accessible only by the user who created it. There is no concept of
 * public data or shared access between users. The security model prioritizes data
* isolation to protect sensitive financial information.
 *
 * Data Structure: The entire data model is hierarchical, rooted in the top-level
 * `/users` collection. Each user's data, including categories, bank accounts,
 * credit cards, transactions, and savings rules, is stored in dedicated subcollections
 * directly under their unique user document (e.g., `/users/{userId}/transactions/{transactionId}`).
 * This structure is fundamental to the security model.
 *
 * Key Security Decisions:
 * - User Enumeration is Disabled: Listing the top-level `/users` collection is explicitly
 *   disallowed to prevent malicious actors from discovering the application's user base.
 * - Path-Based Security: All rules rely on the `{userId}` wildcard in the document path.
 *   This ensures that authorization checks are fast, simple, and don't require costly
 *   `get()` calls to other documents, a practice known as "Authorization Independence".
 * - Default Deny Posture: Access to any path not explicitly defined in these rules is
 *   denied by default. All five operation types (get, list, create, update, delete) are
 *   explicitly defined for every matched path.
 *
 * Denormalization for Authorization: The data structure is designed around this principle.
 * By placing all of a user's data under a path containing their UID (`/users/{userId}/...`),
 * we denormalize the ownership context into the path itself. Furthermore, each document
 * within these subcollections contains a `userId` field, which is used to enforce
 * relational integrity on create and update operations.
 *
 * Structural Segregation: The entire application follows this pattern by design.
 * All data is segregated by user into private subcollections, making it impossible
 * for one user's queries to accidentally access another user's data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the foundation of the ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Verifies that a document exists before an update or delete operation.
     * Also confirms that the authenticated user is the owner.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates that a field remains unchanged during an update operation.
     * Used to protect critical, immutable relational keys like 'id' or 'userId'.
     */
    function isImmutable(field) {
      return request.resource.data[field] == resource.data[field];
    }
    
    /**
     * Validates creation of the root User document.
     * Ensures the user is signed in and the document ID matches their auth UID.
     */
    function isCreatingSelf(userId) {
      return isOwner(userId) && request.resource.data.id == userId;
    }

    /**
     * Validates creation of documents in user-owned subcollections.
     * Ensures the owner is creating data under their own path and that the
     * internal `userId` field correctly links back to them.
     */
    function isCreatingOwnData(userId) {
      return isOwner(userId) && request.resource.data.userId == userId;
    }

    /**
     * Validates updates to the root User document.
     * Ensures the owner is making the change and that the document's unique ID is not altered.
     */
    function isUpdatingOwnProfile(userId) {
      return isExistingOwner(userId) && isImmutable('id');
    }

    /**
     * Validates updates to documents in user-owned subcollections.
     * Ensures the owner is making the change and that the linking `userId` field is not altered.
     */
    function isUpdatingOwnData(userId) {
      return isExistingOwner(userId) && isImmutable('userId');
    }

    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------

    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isCreatingSelf(userId);
      allow update: if isUpdatingOwnProfile(userId);
      allow delete: if isExistingOwner(userId);

      match /categories/{categoryId} {
        allow read: if isOwner(userId);
        allow create: if isCreatingOwnData(userId);
        allow update: if isUpdatingOwnData(userId);
        allow delete: if isOwner(userId);
      }

      match /bankAccounts/{bankAccountId} {
        allow read: if isOwner(userId);
        allow create: if isCreatingOwnData(userId);
        allow update: if isUpdatingOwnData(userId);
        allow delete: if isOwner(userId);
      }

      match /creditCards/{creditCardId} {
        allow read: if isOwner(userId);
        allow create: if isCreatingOwnData(userId);
        allow update: if isUpdatingOwnData(userId);
        allow delete: if isOwner(userId);
      }

      match /transactions/{transactionId} {
        allow read: if isOwner(userId);
        allow create: if isCreatingOwnData(userId);
        allow update: if isUpdatingOwnData(userId);
        allow delete: if isOwner(userId);
      }

      match /savingsRules/{savingsRuleId} {
        allow read: if isOwner(userId);
        allow create: if isCreatingOwnData(userId);
        allow update: if isUpdatingOwnData(userId);
        allow delete: if isOwner(userId);
      }
    }
  }
}
